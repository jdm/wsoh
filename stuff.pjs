/* -*- tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

////////////////////////////////////////////////////////////////////////////////
// stuff.pjs
////////////////////////////////////////////////////////////////////////////////

// constants
int centreRadius = 25;
int rate = 10;

// current beats per minute, doesn't allow for multiple bpms
int curbpm = 0;
// universal tick count
int ticks = 0;

////////////////////////////////////////////////////////////////////////////////
// circle menu UIs

function displayUI(ui) {
    if(!ui.display) {
        return;
    }
    noFill();
    strokeCap(SQUARE);
    // draw the circle background
    var backgroundColor = 64;
    strokeWeight(ui.thickness+2*ui.margin);
    stroke(backgroundColor);
    circle(ui.x, ui.y, ui.r);
    if(ui.sections) {
        // it's a circle menu
        // add up all the weights
        var totalWeight = 0;
        for(var i=0; i < ui.sections.length; i++) {
            if(ui.sections[i].weight)
                totalWeight += ui.sections[i].weight;
            else
                totalWeight += 1;
        }
        ui.totalWeight = totalWeight;
        float bAngle = 0, eAngle = 0, angle = 0;
        int ix, iy, ox, oy;
        noFill();
        // and then partition the segments
        for(var i=0; i < ui.sections.length; i++) {
            if(ui.sections[i].weight)
                eAngle = bAngle + 2*PI*ui.sections[i].weight/totalWeight;
            else
                eAngle = bAngle + 2*PI/totalWeight;
            // draw the arcs
            strokeWeight(ui.thickness);
            if(i == ui.focus)
                stroke(220);
            else
                stroke(255);
            arc(ui.x, ui.y, 2*ui.r, 2*ui.r,
                bAngle+ui.angleOffset, eAngle+ui.angleOffset);

            strokeWeight(ui.margin);
            stroke(backgroundColor);
            var m = ui.thickness/2 + ui.margin/2;
            ix = Math.cos(bAngle+ui.angleOffset)*(ui.r-m);
            iy = Math.sin(bAngle+ui.angleOffset)*(ui.r-m);
            ox = Math.cos(bAngle+ui.angleOffset)*(ui.r+m);
            oy = Math.sin(bAngle+ui.angleOffset)*(ui.r+m);
            line(ix+ui.x,iy+ui.y, ox+ui.x,oy+ui.y);

            ix = Math.cos(eAngle+ui.angleOffset)*(ui.r-m);
            iy = Math.sin(eAngle+ui.angleOffset)*(ui.r-m);
            ox = Math.cos(eAngle+ui.angleOffset)*(ui.r+m);
            oy = Math.sin(eAngle+ui.angleOffset)*(ui.r+m);
            line(ix+ui.x,iy+ui.y, ox+ui.x,oy+ui.y);
            bAngle = eAngle;
        }
    } else if(ui.value != undefined) {
        // it's a slider value
        noFill();
        stroke(255);
        strokeWeight(ui.thickness);
        circle(ui.x,ui.y, ui.r);
        stroke(200);
        var angle = (2*PI*ui.value/(ui.range[1]-ui.range[0])+ui.angleOffset) % (2*PI);
        arc(ui.x,ui.y, 2*ui.r,2*ui.r, ui.angleOffset,angle);
        strokeWeight(ui.thickness+ui.margin);
        strokeCap(ROUND);
        stroke(150);
        // target 20px width
        var dt = 20/(2*PI*ui.r);
        arc(ui.x,ui.y, 2*ui.r,2*ui.r, angle-dt,angle+dt);
    }
    // Fill the middle?
    // fill(color(0,0,0,255));
    // circle(ui.x,ui.y, ui.r-ui.thickness/2-ui.margin/2);
    strokeWeight(1);
}

function pointOnUI(ui, x,y) {
    if(!ui.display)
        return;
    var d = dist(x,y, ui.x,ui.y);
    if(d<ui.r+ui.thickness/2 && d>ui.r-ui.thickness/2) {
        var angle = (atan2(ui.y-y, ui.x-x) + ui.angleOffset + 2*PI) % (2*PI);
        if(ui.sections) {
            // check where in stuff
            var frac = angle/(2*PI);
            var accWeight = 0, i = 0;
            while(accWeight/ui.totalWeight < frac) {
                var w = ui.sections[i].weight;
                accWeight += w ? w : 1;
                i++;
            }
            // just so we can focus some more
            ui.focus = i-1;
        } else if(ui.value != undefined) {
            ui.value = angle/(2*PI)*(ui.range[1]-ui.range[0])+ui.range[0];
            // println(ui.value);
        }
        return true;
    }
    if(ui.sections)
        ui.focus = -1;
    return false;
}

// supposed to be a UI logo element
void drawSine() {
}

// menu for 
var addUI = {x:0, y:0, r:40,
             thickness:50,
             display:false,
             margin:10, angleOffset:-PI/2,
             sections:[{weight:1},
                       {weight:1},
                       {weight:1}
                      ]};

var editUI = {x:0, y:0, r:30,
             thickness:50,
             display:false,
             margin:10, angleOffset:-PI/2,
             sections:[{weight:1},
                       {weight:1},
                      ]};

var volumeUI = {x:0, y:0, r:80,
                thickness:20,
                display:false,
                margin:10, angleOffset:-PI/2,
                value:100, range:[0,100]};

var frequencyUI = {x:0, y:0, r:120,
                   thickness:20,
                   display:false,
                   margin:10, angleOffset:-PI/2,
                   value:35, range:[0,100]};

////////////////////////////////////////////////////////////////////////////////
// required by processing.js
void setup() {
    size(screen.width, screen.height);
    frameRate(rate);

    // plops down the center
    int cx = width / 2 - centreRadius;
    int cy = height / 2 - centreRadius;
    HomeNode.x = cx;
    HomeNode.y = cy;
    HomeNode.size = centreRadius;
    HomeNode.influence = 200;
}

function circle(x,y,radius) {
    ellipse(x,y,2*radius,2*radius);
}

// required by processing.js
void draw() {
    // drawing background
    background(125);
    fill(255);

    if (curbpm != bpm) {
        curbpm = bpm;
        ticks = curbpm / 60;
    }

    //// Draw Layers
    // Draw the influence circles
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];

        if(node.mouseOver) {
            println("show influence circle");
            // display an influence circle, opacity
            fill(color(255, 255, 255, 50));
            stroke(color(0,0,0,100));
            circle(node.x, node.y, node.influence);
        } else {
            fill(color(255, 255, 255, 20));
            stroke(color(0,0,0,20));
            circle(node.x, node.y, node.influence);
        }
    }
    // reset the stroke
    stroke(color(0,0,0,255));

    // Draw relationships
    for (int i=0; i < nodeList.length; i++) {
        var node = nodeList[i];
        stroke(0);
        fill(0);
        int base = 1.5;
        for(int j=0; j < node.inputNodes.length; j++) {
            // input into this node
            var parent = node.inputNodes[j];
            // replace with a triangle, to show direction
            int dx = parent.x - node.x;
            int dy = parent.y - node.y;
            int norm = dist(0,0, dx,dy);
            triangle(parent.x + base*dy/norm, parent.y - base*dx/norm,
                     parent.x - base*dy/norm, parent.y + base*dx/norm,
                     node.x, node.y);
        }
    }

    // Draw all nodes proper
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        fill(node.color);

        switch (node.shape) {
        case Circle:
            circle(node.x, node.y, node.size);
            break;
        case Square:
            rect(node.x - node.size, node.y - node.size, node.size * 2, node.size * 2);
            break;
        }
    }

    // draw UIs, if needed
    displayUI(addUI);
    displayUI(editUI);
    displayUI(volumeUI);
    displayUI(frequencyUI);

    generateAudio();
}

////////////////////////////////////////////////////////////////////////////////
// Mouse events

void mousePressed() {
    var x=mouseX,y=mouseY;
    // check node pressed
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        if (node.pointInShape.call(node, mouseX, mouseY)) {
            node.pressed = true;
        } else {
            node.pressed = false;
        }
    }
    if(pointOnUI(volumeUI, x,y)) {
        volumeUI.click = true;
    } else {
        volumeUI.click = false;
    }
    if(pointOnUI(frequencyUI, x,y)) {
        frequencyUI.click = true;
    } else {
        frequencyUI.click = false;
    }
}

void mouseClicked() {
    int x = mouseX;
    int y = mouseY;
    // check if the click falls into an object
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        if (node.pointInShape.call(node, mouseX, mouseY)) {
            editUI.x = node.x;
            volumeUI.x = node.x;
            frequencyUI.x = node.x;
            editUI.y = node.y;
            volumeUI.y = node.y;
            frequencyUI.y = node.y;
            editUI.display = true;
            volumeUI.display = true;
            frequencyUI.display = true;
            addUI.display = false;
            return;
        }
    }
    if(pointOnUI(editUI, x,y) || 
       pointOnUI(volumeUI, x,y) || 
       pointOnUI(frequencyUI, x,y)) {
        return;
    } else {
        if(editUI.display) {
            editUI.display = false;
            volumeUI.display = false;
            frequencyUI.display = false;
            return; // don't lay down addUI
        }
    }
    // otherwise, we're placing an object
    if(addUI.display) {
        if(pointOnUI(addUI, x,y)) {
            // if it's on the UI, pass on

            // ### for now, insert here
            // don't insert yet
            var newNode = make_random_osc(addUI.x, addUI.y);
            // add us as children if inside influence
            for (int i = 0; i < nodeList.length; i++) {
                var node = nodeList[i];
                if (node.intersect.call(node, newNode)) {
                    // newNode will take node as an influence
                    node.inputNodes.push(newNode);
                }
            }
            addNode(newNode);
        }
        addUI.display = false;
    } else {
        addUI.x = x;
        addUI.y = y;
        addUI.display = true;
    }
}

/* 
            // remove node, and all inputs
            for (int j = 0; j < nodeList.length; j++) {
                var k = nodeList[j].inputNodes.indexOf(node);
                if(k != -1) {
                    nodeList[j].inputNodes.splice(k, 1);
                    nodeList[j].inputs.splice(k, 1);
                }
            }
            removeNode(i);
*/

void mouseDragged() {
    var x = mouseX, y = mouseY;
    for(int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        // do elemental dragging
        if(node.pressed) {
            node.x = x;
            node.y = y;
        }
    }
    if(volumeUI.click)
        pointOnUI(volumeUI, x,y);
    if(frequencyUI.click)
        pointOnUI(frequencyUI, x,y);
}

void mouseReleased() {
    for(int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        node.pressed = false;
    }
    volumeUI.click = false;
    frequencyUI.click = false;
}

// analogous to onmousemove
void mouseMoved() {
    var x = mouseX, y = mouseY;
    for(int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        if (node.pointInShape.call(node, x, y)) {
            node.mouseOver = true;
        } else {
            node.mouseOver = false;
        }
    }
    pointOnUI(addUI, x,y);
    pointOnUI(editUI, x,y);
}
