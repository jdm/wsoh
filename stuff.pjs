////////////////////////////////////////////////////////////////////////////////
// stuff.pjs
////////////////////////////////////////////////////////////////////////////////

// constants
int centreRadius = 25;
int rate = 10; // lower rate

// current beats per minute, doesn't allow for multiple bpms
int curbpm = 0;
// universal tick count
int ticks = 0;

// required by processing.js
void setup() {
    size(screen.width, screen.height);
    frameRate(rate);

    // plops down the center
    int cx = width / 2 - centreRadius;
    int cy = height / 2 - centreRadius;
    HomeNode.x = cx;
    HomeNode.y = cy;
    HomeNode.size = centreRadius;
    HomeNode.influence = 200;
    // var center = new Node(cx, cy, Circle, function(){}, {size:centreRadius, influence:200});
    nodeList.push(center);
}

function circle(x,y,radius) {
    ellipse(x,y,2*radius,2*radius);
}

// required by processing.js
void draw() {
    // drawing background
    background(125);
    fill(255);

    if (curbpm != bpm) {
        curbpm = bpm;
        ticks = curbpm / 60;
    }

    //// Draw Layers
    // Draw the influence circles
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];

        if(node.mouseOver) {
            println("show influence circle");
            // display an influence circle
            fill(color(255, 255, 255, 128));
            circle(node.x, node.y, node.influence);
        }
    }

    // Draw relationships
    for (int i=0; i < nodeList.length; i++) {
        var node = nodeList[i];
        stroke(0);
        for(int j=0; j < node.inputNodes.length; j++) {
            var child = node.inputNodes[j];
            // replace with a triangle, to show direction
            line(node.x,node.y, child.x,child.y);
        }
    }

    // Draw all nodes proper
    println(nodeList.length);
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        fill(node.color);

        switch (node.shape) {
        case Circle:
            circle(node.x, node.y, node.size);
            // ellipse(node.x - node.size, node.y - node.size, node.size * 2, node.size * 2);
            break;
        case Square:
            rect(node.x - node.size, node.y - node.size, node.size * 2, node.size * 2);
            break;
        }
    }
    generateAudio();
}

////////////////////////////////////////////////////////////////////////////////
// Mouse events

void mouseClicked() {
    // check if the click falls into an object
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        if (node.pointInShape.call(node, mouseX, mouseY)) {
            println("intersect");
            removeNode(i);
            return;
        }
    }
    // otherwise, we're placing an object
    int x = mouseX;
    int y = mouseY;
    var newNode = addNode(make_random_osc(x, y));
    // add us as children if inside influence
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        if (node.intersect.call(node, newNode)) {
            println("node in influence");
            node.inputNodes.push(newNode);
        }
    }
    nodeList.push(newNode);
}

void mouseMoved() {
    for (int i = 0; i < nodeList.length; i++) {
        var node = nodeList[i];
        if (node.pointInShape.call(node, mouseX, mouseY)) {
            node.mouseOver = true;
        } else {
            node.mouseOver = false;
        }
    } 
}
